# DCIM Macro 架构设计文档

## 1. 系统概述

DCIM Macro是一个基于SRAM的数字存算一体计算宏，借鉴TSMC在ISSCC 2023中提出的设计思想，实现了高效的可变位宽计算架构。

### 1.1 主要特性
- **可变位宽支持**：12/24b整数权重与12/24b整数输入
- **并行计算**：8个OAI乘法器并行工作
- **Ping-Pong结构**：支持权重写入与计算并行
- **符号扩展机制**：兼容有符号和无符号运算

### 1.2 性能指标
- **计算精度**：12/24b整数运算
- **并行度**：8个乘法器并行，16个模块级联
- **存储容量**：每个bank 8×24-bit SRAM
- **时钟频率**：设计目标100MHz

## 2. 系统架构

### 2.1 顶层模块结构
```
top.v
├── cim_array.v（含cim_bank.v）
└── digital_circuit.v
     ├── cim_array_ctrl.v（阵列控制）
     ├── global_io.v（全局IO，含累加器）
     │   ├── add.v
     │   └── accumulator.v（含se_cla.v、s_cla.v）
     ├── local_mac.v（局部MAC，含oai_mult.v）
     ├── rwldrv.v（读字线驱动）
     └── gctrl.v（全局控制）
```

### 2.2 数据流
1. **权重加载**：通过D和WA端口将权重写入SRAM阵列
2. **输入处理**：xin0输入向量通过rwldrv模块串并转换
3. **乘法运算**：OAI乘法器执行1b×12b乘法
4. **累加计算**：加法树累加8个乘法结果
5. **全局累加**：Global IO对多周期结果移位累加
6. **结果输出**：51位最终结果通过nout端口输出

## 3. 关键模块设计

### 3.1 SRAM存储阵列 (cim_array.v, cim_bank.v)

#### 功能描述
- 实现8×24-bit SRAM存储体
- 支持one-hot地址编码的写操作
- 根据rwlb信号进行读操作

#### 关键特性
```verilog
// 写操作 - one-hot地址编码
case (WA)
    8'b00000001: mem[0] = D;
    8'b00000010: mem[1] = D;
    // ... 其他地址
endcase

// 读操作 - 根据rwlb信号选择输出
if (rwlb_row0[i]) begin
    wb_a[11:0] = mem[i][11:0];   // 第0位权重
    wb_a[23:12] = mem[i][23:12]; // 第1位权重
    // ... 其他位
end
```

### 3.2 局部MAC (local_mac.v)

#### 功能描述
- 实现8个OAI乘法器的并行计算
- 三级加法器树实现高效累加
- 支持有符号/无符号运算

#### 架构设计
```
8个OAI乘法器 → 4个加法器 → 2个加法器 → 1个加法器
     ↓              ↓            ↓           ↓
  mult_out[7:0] → add1_out[3:0] → add2_out[1:0] → mac_out
```

#### OAI乘法器 (oai_mult.v)
```verilog
// OAI逻辑：e = ~((a | c) & (b | d))
assign e = ~((a | c_ext) & (b | d_ext));
```

### 3.3 全局控制器 (gctrl.v)

#### 功能描述
- 生成计算步进控制信号
- 根据位宽配置调整计数上限
- 控制累加器的启停

#### 状态机设计
```verilog
parameter IDLE = 2'b00;   // 空闲状态
parameter COUNT = 2'b01;  // 计数状态
parameter DONE = 2'b10;   // 完成状态

// 计数器上限
wire [5:0] max_count = inwidth ? 6'd23 : 6'd11;
```

### 3.4 读字线驱动 (rwldrv.v)

#### 功能描述
- 将192-bit输入分解为24组8-bit数据
- 根据sel信号选择特定位
- 生成行驱动信号

#### 数据分解
```verilog
// 将192-bit输入分解为24组8-bit数据
assign xin_w[0] = xin0[7:0];
assign xin_w[1] = xin0[15:8];
// ... 其他位
```

### 3.5 全局IO (global_io.v)

#### 功能描述
- 处理两个local_mac的输出
- 根据权重位宽进行移位操作
- 驱动累加器进行最终累加

#### 移位逻辑
```verilog
// 根据权重位宽对macout_b进行移位
assign macout_b_shifted = wwidth ? {macout_b[13:0], 1'b0} : macout_b;
```

### 3.6 累加器 (accumulator.v)

#### 功能描述
- 51位移位累加器
- 支持多周期结果累加
- 集成符号扩展先行进位加法器

#### 累加逻辑
```verilog
// st为低时，进行移位累加
nout_1 <= {nout[49:0], 1'b0};  // 左移一位

// st为高时，清零累加结果
nout_1 <= 51'b0;
```

## 4. 位宽配置机制

### 4.1 符号扩展机制
- **前4个周期**：执行4b有符号操作
- **其余周期**：4b无符号操作
- **控制信号**：`sus = (sel < 4) ? 1'b1 : 1'b0`

### 4.2 位宽切换
- **12-bit模式**：计数上限为11，12个周期完成
- **24-bit模式**：计数上限为23，24个周期完成
- **权重位宽**：通过wwidth信号控制移位操作

## 5. Ping-Pong结构

### 5.1 设计原理
- 阵列设计为2rows（bank0和bank1）
- 通过cima信号选择当前操作的bank
- 一个bank用于写操作时，另一个bank可同时进行计算

### 5.2 实现方式
```verilog
// 地址路由逻辑
if (cima == 1'b0) begin
    WA0 = WA;  // bank0使能
    WA1 = 8'b0; // bank1不使能
end else begin
    WA0 = 8'b0; // bank0不使能
    WA1 = WA;  // bank1使能
end
```

## 6. 时序控制

### 6.1 时钟域
- 系统时钟：100MHz
- 所有寄存器操作在时钟上升沿进行
- 组合逻辑路径需要满足时序约束

### 6.2 控制信号时序
```
start → gctrl → sel → rwldrv → local_mac → global_io → accumulator
  ↓       ↓      ↓       ↓         ↓           ↓           ↓
 复位    计数   选择   驱动     计算       累加       输出
```

## 7. 仿真验证

### 7.1 测试场景
1. **权重写入测试**：验证SRAM写入功能
2. **12-bit模式测试**：验证12-bit计算功能
3. **24-bit模式测试**：验证24-bit计算功能
4. **Ping-Pong测试**：验证并行操作功能

### 7.2 仿真结果
- **12-bit模式**：12个周期完成，结果正确
- **24-bit模式**：24个周期完成，结果正确
- **累加过程**：每个周期累加结果递增
- **最终输出**：51位结果符合预期

## 8. 扩展性设计

### 8.1 存储扩展
- 可通过增加bank数量扩展存储容量
- 支持更大规模的权重矩阵

### 8.2 计算扩展
- 可通过增加乘法器数量提高并行度
- 支持更复杂的计算模式

### 8.3 位宽扩展
- 架构支持更高位宽配置
- 可通过修改参数适应不同精度需求

## 9. 性能优化

### 9.1 关键路径优化
- OAI乘法器采用组合逻辑设计
- 加法器树采用并行结构
- 累加器采用流水线设计

### 9.2 功耗优化
- 采用时钟门控技术
- 未使用的bank可进入低功耗模式
- 动态位宽切换减少不必要的计算

## 10. 总结

DCIM Macro架构成功实现了基于SRAM的数字存算一体计算，具有以下优势：

1. **高效计算**：OAI乘法器和并行加法器树提供高性能计算
2. **灵活配置**：支持12/24b位宽切换，适应不同应用需求
3. **并行操作**：Ping-Pong结构支持权重写入与计算并行
4. **可扩展性**：模块化设计便于功能扩展和性能提升
5. **验证完整**：通过仿真验证了所有关键功能

该架构为数字存算一体技术的发展提供了有价值的参考实现。 